var search_data = {"index":{"searchIndex":["rparsec","expressions","functormixin","functors","keywords","monad","operatortable","operators","parser","parsers","token","*()","<<()",">>()",">>()","[]()","alt()","among()","any()","are()","arent()","atomize()","bind()","bindn()","build()","canonical_name()","case_insensitive()","case_sensitive()","case_sensitive?()","catchp()","char()","comment_block()","comment_line()","compose()","compose()","const()","copy_words()","curry()","curry()","delimited()","delimited1()","eof()","expect()","failure()","flip()","flip()","followed()","fragment()","get_index()","infixl()","infixn()","infixr()","initmonad()","integer()","is()","isnt()","lazy()","length()","lexeme()","lexer()","longer()","longest()","make_curry()","make_lexer()","make_reverse_curry()","many()","many_()","map()","map()","map()","mapn()","mapn()","nested()","new()","new()","new()","new()","not()","not_among()","not_char()","not_string()","nth()","number()","one()","optional()","parse()","parser()","parser()","peek()","plus()","postfix()","power()","power()","prefix()","range()","regexp()","repeat()","repeat()","repeat()","repeat_()","reverse_curry()","reverse_curry()","reverse_uncurry()","reverse_uncurry()","satisfies()","separated()","separated1()","seq()","seq()","sequence()","set_index()","shorter()","shortest()","some()","some_()","sort()","str()","string()","string_nocase()","sum()","throwp()","to_s()","to_s()","token()","token()","uncurry()","uncurry()","value()","value()","watch()","watchn()","whitespace()","whitespaces()","word()","zero()","|()","~()","changelog","readme","overview","sql","tips"],"longSearchIndex":["rparsec","rparsec::expressions","rparsec::functormixin","rparsec::functors","rparsec::keywords","rparsec::monad","rparsec::operatortable","rparsec::operators","rparsec::parser","rparsec::parsers","rparsec::token","rparsec::parser#*()","rparsec::parser#<<()","rparsec::functormixin#>>()","rparsec::parser#>>()","rparsec::operators#[]()","rparsec::parsers#alt()","rparsec::parsers#among()","rparsec::parsers#any()","rparsec::parsers#are()","rparsec::parsers#arent()","rparsec::parser#atomize()","rparsec::monad#bind()","rparsec::parser#bindn()","rparsec::expressions::build()","rparsec::keywords#canonical_name()","rparsec::keywords::case_insensitive()","rparsec::keywords::case_sensitive()","rparsec::keywords#case_sensitive?()","rparsec::parser#catchp()","rparsec::parsers#char()","rparsec::parsers#comment_block()","rparsec::parsers#comment_line()","rparsec::functormixin#compose()","rparsec::functors#compose()","rparsec::functors#const()","rparsec::keywords#copy_words()","rparsec::functormixin#curry()","rparsec::functors#curry()","rparsec::parser#delimited()","rparsec::parser#delimited1()","rparsec::parsers#eof()","rparsec::parser#expect()","rparsec::parsers#failure()","rparsec::functormixin#flip()","rparsec::functors#flip()","rparsec::parser#followed()","rparsec::parser#fragment()","rparsec::parsers#get_index()","rparsec::parser#infixl()","rparsec::parser#infixn()","rparsec::parser#infixr()","rparsec::monad#initmonad()","rparsec::parsers#integer()","rparsec::parsers#is()","rparsec::parsers#isnt()","rparsec::parsers#lazy()","rparsec::token#length()","rparsec::parser#lexeme()","rparsec::operators#lexer()","rparsec::parsers#longer()","rparsec::parsers#longest()","rparsec::functors::make_curry()","rparsec::keywords#make_lexer()","rparsec::functors::make_reverse_curry()","rparsec::parser#many()","rparsec::parser#many_()","rparsec::monad#map()","rparsec::parser#map()","rparsec::parsers#map()","rparsec::parser#mapn()","rparsec::parsers#mapn()","rparsec::parser#nested()","rparsec::keywords::new()","rparsec::operatortable::new()","rparsec::operators::new()","rparsec::parser::new()","rparsec::parser#not()","rparsec::parsers#not_among()","rparsec::parsers#not_char()","rparsec::parsers#not_string()","rparsec::functors#nth()","rparsec::parsers#number()","rparsec::parsers#one()","rparsec::parser#optional()","rparsec::parser#parse()","rparsec::keywords#parser()","rparsec::operators#parser()","rparsec::parser#peek()","rparsec::monad#plus()","rparsec::parser#postfix()","rparsec::functormixin#power()","rparsec::functors#power()","rparsec::parser#prefix()","rparsec::parsers#range()","rparsec::parsers#regexp()","rparsec::functormixin#repeat()","rparsec::functors#repeat()","rparsec::parser#repeat()","rparsec::parser#repeat_()","rparsec::functormixin#reverse_curry()","rparsec::functors#reverse_curry()","rparsec::functormixin#reverse_uncurry()","rparsec::functors#reverse_uncurry()","rparsec::parsers#satisfies()","rparsec::parser#separated()","rparsec::parser#separated1()","rparsec::monad#seq()","rparsec::parser#seq()","rparsec::parsers#sequence()","rparsec::parsers#set_index()","rparsec::parsers#shorter()","rparsec::parsers#shortest()","rparsec::parser#some()","rparsec::parser#some_()","rparsec::operators::sort()","rparsec::parsers#str()","rparsec::parsers#string()","rparsec::parsers#string_nocase()","rparsec::parsers#sum()","rparsec::parsers#throwp()","rparsec::parser#to_s()","rparsec::token#to_s()","rparsec::parser#token()","rparsec::parsers#token()","rparsec::functormixin#uncurry()","rparsec::functors#uncurry()","rparsec::monad#value()","rparsec::parsers#value()","rparsec::parsers#watch()","rparsec::parsers#watchn()","rparsec::parsers#whitespace()","rparsec::parsers#whitespaces()","rparsec::parsers#word()","rparsec::parsers#zero()","rparsec::parser#|()","rparsec::parser#~()","","","","",""],"info":[["RParsec","","RParsec.html","",""],["RParsec::Expressions","","RParsec/Expressions.html","","<p>This module helps build an expression parser using an OperatorTable instance and a parser that parses …\n"],["RParsec::FunctorMixin","","RParsec/FunctorMixin.html","","<p>This module provides instance methods that manipulate closures in a functional style. It is typically …\n"],["RParsec::Functors","","RParsec/Functors.html","","<p>This module provides frequently used functors.\n"],["RParsec::Keywords","","RParsec/Keywords.html","","<p>This class helps building lexers and parsers for keywords.\n"],["RParsec::Monad","","RParsec/Monad.html","","<p>module for Monad\n"],["RParsec::OperatorTable","","RParsec/OperatorTable.html","","<p>This class holds information about operator precedences and associativities.  <code>prefix</code>, <code>postfix</code>, <code>infixl</code> …\n"],["RParsec::Operators","","RParsec/Operators.html","","<p>This class helps building lexer and parser for operators.  The case that one operator (<code>++</code> for example) …\n"],["RParsec::Parser","","RParsec/Parser.html","","<p>Represents a parser that parses a certain grammar rule.\n"],["RParsec::Parsers","","RParsec/Parsers.html","","<p>This module provides all out-of-box parser implementations.\n"],["RParsec::Token","","RParsec/Token.html","",""],["*","RParsec::Parser","RParsec/Parser.html#method-i-2A","(min, max = min)",""],["<<","RParsec::Parser","RParsec/Parser.html#method-i-3C-3C","(other)",""],[">>","RParsec::FunctorMixin","RParsec/FunctorMixin.html#method-i-3E-3E","(other)","<p><code>a &gt;&gt; b</code> is equivalent to <code>b &lt;&lt; a</code>.  See also #<<.\n"],[">>","RParsec::Parser","RParsec/Parser.html#method-i-3E-3E","(other)","<p>Similar to #seq.  <code>other</code> is auto-boxed if it is not of type Parser.\n"],["[]","RParsec::Operators","RParsec/Operators.html#method-i-5B-5D","(op)",""],["alt","RParsec::Parsers","RParsec/Parsers.html#method-i-alt","(*alts)","<p>A parser that calls alternative parsers until one succeeds.\n"],["among","RParsec::Parsers","RParsec/Parsers.html#method-i-among","(*vals)","<p>A parser that succeeds when the the current input is among the given values.\n"],["any","RParsec::Parsers","RParsec/Parsers.html#method-i-any","()","<p>A parser that consumes one input.\n"],["are","RParsec::Parsers","RParsec/Parsers.html#method-i-are","(vals, expected = \"#{vals} expected\")","<p>A parser that tries to match the current inputs one by one with the given values. It succeeds only when …\n"],["arent","RParsec::Parsers","RParsec/Parsers.html#method-i-arent","(vals, expected = \"#{vals} unexpected\")","<p>A parser that makes sure that the given values don’t match the current inputs. One input is consumed …\n"],["atomize","RParsec::Parser","RParsec/Parser.html#method-i-atomize","()","<p>Create a new parser that’s atomic, meaning that when it fails, input consumption is undone.\n"],["bind","RParsec::Monad","RParsec/Monad.html#method-i-bind","(&binder)","<p>Run the <em>bind</em> operation on the encapsulated object following the monad law.\n"],["bindn","RParsec::Parser","RParsec/Parser.html#method-i-bindn","(&block)","<p><code>self</code> is first executed, the parser result is then passed as parameter to the associated <code>block</code>, which …\n"],["build","RParsec::Expressions","RParsec/Expressions.html#method-c-build","(term, table, delim = nil)","<p>build an expression parser using the given <code>term</code> parser and operator <code>table</code>.  When <code>delim</code> is specified, …\n"],["canonical_name","RParsec::Keywords","RParsec/Keywords.html#method-i-canonical_name","(name)",""],["case_insensitive","RParsec::Keywords","RParsec/Keywords.html#method-c-case_insensitive","(words, default_lexer = word.token(:word), keyword_symbol = :keyword, &block)","<p>To create an instance that lexes the given keywords case insensitively.  <code>default_lexer</code> is used to lex …\n"],["case_sensitive","RParsec::Keywords","RParsec/Keywords.html#method-c-case_sensitive","(words, default_lexer = word.token(:word), keyword_symbol = :keyword, &block)","<p>To create an instance that lexes the given keywords case sensitively.  <code>default_lexer</code> is used to lex a …\n"],["case_sensitive?","RParsec::Keywords","RParsec/Keywords.html#method-i-case_sensitive-3F","(= @case_sensitive)","<p>Do we lex case sensitively?\n"],["catchp","RParsec::Parser","RParsec/Parser.html#method-i-catchp","(symbol)","<p><code>a.catchp(:somesymbol)</code> will catch the <code>:somesymbol</code> thrown by <code>a</code>.\n"],["char","RParsec::Parsers","RParsec/Parsers.html#method-i-char","(c)","<p>A parser that succeeds when the the current input is the given character.\n"],["comment_block","RParsec::Parsers","RParsec/Parsers.html#method-i-comment_block","(open, close)","<p>A parser that parses a chunk of text started with <code>open</code> and ended by <code>close</code>.  <code>nil</code> is the result.\n"],["comment_line","RParsec::Parsers","RParsec/Parsers.html#method-i-comment_line","(start)","<p>A parser that parses a line started with <code>start</code>.  <code>nil</code> is the result.\n"],["compose","RParsec::FunctorMixin","RParsec/FunctorMixin.html#method-i-compose","(other)","<p>Create a <code>Proc</code>, when called, the parameter is first passed into <code>other</code>, <code>self</code> is called in turn with the …\n"],["compose","RParsec::Functors","RParsec/Functors.html#method-i-compose","(f1, f2)","<p>Create a <code>Proc</code>, when called, the parameter is first passed into <code>f2</code>, <code>f1</code> is called in turn with the return …\n"],["const","RParsec::Functors","RParsec/Functors.html#method-i-const","(v)","<p>Get a <code>Proc</code>, when called, always return the given value.\n"],["copy_words","RParsec::Keywords","RParsec/Keywords.html#method-i-copy_words","(words, case_sensitive)",""],["curry","RParsec::FunctorMixin","RParsec/FunctorMixin.html#method-i-curry","(ary = arity)",""],["curry","RParsec::Functors","RParsec/Functors.html#method-i-curry","(arity, &block)","<p>Create a <code>Proc</code> that’s curriable.  When curried, parameters are passed in from left to right. i.e. …\n"],["delimited","RParsec::Parser","RParsec/Parser.html#method-i-delimited","(delim)","<p>To create a parser that repeats <code>self</code> for unlimited times, with the pattern recognized by <code>delim</code> as separator …\n"],["delimited1","RParsec::Parser","RParsec/Parser.html#method-i-delimited1","(delim)","<p>To create a parser that repeats <code>self</code> for unlimited times, with the pattern recognized by <code>delim</code> as separator …\n"],["eof","RParsec::Parsers","RParsec/Parsers.html#method-i-eof","(expected = \"EOF expected\")","<p>A parser that succeeds when there’s no input available.\n"],["expect","RParsec::Parser","RParsec/Parser.html#method-i-expect","(msg)","<p>To create a parser that fails with a given error message.\n"],["failure","RParsec::Parsers","RParsec/Parsers.html#method-i-failure","(msg)","<p>A parser that always fails with the given error message.\n"],["flip","RParsec::FunctorMixin","RParsec/FunctorMixin.html#method-i-flip","(= Functors.flip(&self))","<p>Create a <code>Proc</code>, which expects the two parameters in the reverse order of <code>self</code>.\n"],["flip","RParsec::Functors","RParsec/Functors.html#method-i-flip","(&block)","<p>Create a <code>Proc</code>, which expects the two parameters in the reverse order of <code>block</code>.\n"],["followed","RParsec::Parser","RParsec/Parser.html#method-i-followed","(other)","<p><code>a.followed b</code> will sequentially run <code>a</code> and <code>b</code>; result of a is preserved as the ultimate return value.\n"],["fragment","RParsec::Parser","RParsec/Parser.html#method-i-fragment","()","<p><code>a.fragment</code> will return the string matched by <code>a</code>.\n"],["get_index","RParsec::Parsers","RParsec/Parsers.html#method-i-get_index","()","<p>A parser that returns the current input index (starting from 0).\n"],["infixl","RParsec::Parser","RParsec/Parser.html#method-i-infixl","(op)","<p>For left-associative infix binary operator.  <code>op</code> has to return a <code>Proc</code> that takes two parameters, who are …\n"],["infixn","RParsec::Parser","RParsec/Parser.html#method-i-infixn","(op)","<p>For non-associative infix binary operator.  <code>op</code> has to return a <code>Proc</code> that takes two parameters, who are …\n"],["infixr","RParsec::Parser","RParsec/Parser.html#method-i-infixr","(op)","<p>For right-associative infix binary operator.  <code>op</code> has to return a <code>Proc</code> that takes two parameters, who …\n"],["initMonad","RParsec::Monad","RParsec/Monad.html#method-i-initMonad","(m, v)","<p>To initialize with a monad implementation and an object that obeys the monad law.\n"],["integer","RParsec::Parsers","RParsec/Parsers.html#method-i-integer","(expected = 'integer expected')","<p>A parser that parses an integer and return the matched integer as string.\n"],["is","RParsec::Parsers","RParsec/Parsers.html#method-i-is","(v, expected = \"#{v} expected\")","<p>A parser that succeeds when the the current input is equal to the given value.  <code>expected</code> is the error …\n"],["isnt","RParsec::Parsers","RParsec/Parsers.html#method-i-isnt","(v, expected = \"#{v} unexpected\")","<p>A parser that succeeds when the the current input is not equal to the given value.  <code>expected</code> is the error …\n"],["lazy","RParsec::Parsers","RParsec/Parsers.html#method-i-lazy","(&block)","<p>A lazy parser, when executed, calls the given <code>block</code> to get a parser object and delegate the call to this …\n"],["length","RParsec::Token","RParsec/Token.html#method-i-length","(= @text.length)","<p>The length of the token.\n"],["lexeme","RParsec::Parser","RParsec/Parser.html#method-i-lexeme","(delim = Parsers.whitespaces)","<p><code>a.lexeme(delim)</code> will parse <code>a</code> for 0 or more times and ignore all patterns recognized by <code>delim</code>.  Values …\n"],["lexer","RParsec::Operators","RParsec/Operators.html#method-i-lexer","(op = nil)","<p>Get the lexer that lexes operators. If an operator is specified, the lexer for that operator is returned. …\n"],["longer","RParsec::Parsers","RParsec/Parsers.html#method-i-longer","(*parsers)",""],["longest","RParsec::Parsers","RParsec/Parsers.html#method-i-longest","(*parsers)","<p>A parser that tries all given alternative <code>parsers</code> and picks the one with the longest match.\n"],["make_curry","RParsec::Functors","RParsec/Functors.html#method-c-make_curry","(arity, &block)",""],["make_lexer","RParsec::Keywords","RParsec/Keywords.html#method-i-make_lexer","(default_lexer, word_map)",""],["make_reverse_curry","RParsec::Functors","RParsec/Functors.html#method-c-make_reverse_curry","(arity, &block)",""],["many","RParsec::Parser","RParsec/Parser.html#method-i-many","(least = 0)","<p>To create a parser that repeats <code>self</code> for at least <code>least</code> times.  All return values are collected in an …\n"],["many_","RParsec::Parser","RParsec/Parser.html#method-i-many_","(least = 0)","<p>To create a parser that repeats <code>self</code> for at least <code>least</code> times.  <code>parser.many_</code> is equivalent to bnf notation …\n"],["map","RParsec::Monad","RParsec/Monad.html#method-i-map","(&mapper)","<p>Run the <em>map</em> operation on the encapsulated object following the monad law.  #bind is used to implement. …\n"],["map","RParsec::Parser","RParsec/Parser.html#method-i-map","(&block)","<p><code>a.map { |x| x + 1 }</code> will first execute parser <code>a</code>, when it succeeds, the associated block is executed to …\n"],["map","RParsec::Parsers","RParsec/Parsers.html#method-i-map","(&block)","<p>A parser that maps current parser result to a new result using the given <code>block</code>.\n<p>Different from Parser#map …\n"],["mapn","RParsec::Parser","RParsec/Parser.html#method-i-mapn","(&block)","<p><code>a.mapn { |x, y| x + y }</code> will first execute parser <code>a</code>, when it succeeds, the array result (if any) is expanded …\n"],["mapn","RParsec::Parsers","RParsec/Parsers.html#method-i-mapn","(&block)","<p>A parser that maps current parser result to a new result using the given <code>block</code>.  If the current parser …\n"],["nested","RParsec::Parser","RParsec/Parser.html#method-i-nested","(parser)","<p><code>a.nested b</code> will feed the token array returned by parser <code>a</code> to parser <code>b</code> for a nested parsing.\n"],["new","RParsec::Keywords","RParsec/Keywords.html#method-c-new","(words, case_sensitive, default_lexer, keyword_symbol, &block)","<p>scanner has to return a string\n"],["new","RParsec::OperatorTable","RParsec/OperatorTable.html#method-c-new","()","<p>To create an OperatorTable instance.  If a block is given, it is invoked to do post-instantiation.   …\n"],["new","RParsec::Operators","RParsec/Operators.html#method-c-new","(ops, &block)","<p>To create an instance of Operators for the given operators.  The <code>block</code> parameter, if present, is used …\n"],["new","RParsec::Parser","RParsec/Parser.html#method-c-new","()",""],["not","RParsec::Parser","RParsec/Parser.html#method-i-not","(msg = \"#{self} unexpected\")","<p>To create a new parser that succeed only if <code>self</code> fails.\n"],["not_among","RParsec::Parsers","RParsec/Parsers.html#method-i-not_among","(*vals)","<p>A parser that succeeds when the the current input is not among the given values.\n"],["not_char","RParsec::Parsers","RParsec/Parsers.html#method-i-not_char","(c)","<p>A parser that succeeds when the the current input is not the given character.\n"],["not_string","RParsec::Parsers","RParsec/Parsers.html#method-i-not_string","(str, msg = \"\\\"#{str}\\\" unexpected\")","<p>A parser that makes sure that the current input doesn’t match a string. One character is consumed …\n"],["nth","RParsec::Functors","RParsec/Functors.html#method-i-nth","(n)","<p>Get a <code>Proc</code>, when called, return the <code>n</code>th parameter.\n"],["number","RParsec::Parsers","RParsec/Parsers.html#method-i-number","(expected = 'number expected')","<p>A parser that parses a number (integer, or decimal number) and return the matched number as string.\n"],["one","RParsec::Parsers","RParsec/Parsers.html#method-i-one","()","<p>A parser that always succeeds.\n"],["optional","RParsec::Parser","RParsec/Parser.html#method-i-optional","(default = nil)","<p><code>a.optional(default)</code> is equivalent to <code>a.plus(value(default))</code>.  See also #plus and #value.\n"],["parse","RParsec::Parser","RParsec/Parser.html#method-i-parse","(src)","<p>parses a string.\n"],["parser","RParsec::Keywords","RParsec/Keywords.html#method-i-parser","(key)","<p>Get the parser that recognizes the token of the given keyword during the parsing phase.\n"],["parser","RParsec::Operators","RParsec/Operators.html#method-i-parser","(op)","<p>Get the parser for the given operator.\n"],["peek","RParsec::Parser","RParsec/Parser.html#method-i-peek","()","<p>Create a new parser that looks at inputs whthout consuming them.\n"],["plus","RParsec::Monad","RParsec/Monad.html#method-i-plus","(other)","<p>Run the <em>plus</em> operation on the encapsulated object following the MonadPlus law.\n"],["postfix","RParsec::Parser","RParsec/Parser.html#method-i-postfix","(op)","<p>For postfix unary operator.  <code>a.postfix op</code> will run parser <code>a</code> for once and then <code>op</code> for 0 or more times. …\n"],["power","RParsec::FunctorMixin","RParsec/FunctorMixin.html#method-i-power","(n)","<p>Create a <code>Proc</code>, when called, repeatedly call <code>self</code> for <code>n</code> times.  At each iteration, return value from the …\n"],["power","RParsec::Functors","RParsec/Functors.html#method-i-power","(n, &block)","<p>Create a <code>Proc</code>, when called, repeatedly call <code>block</code> for <code>n</code> times.  At each iteration, return value from …\n"],["prefix","RParsec::Parser","RParsec/Parser.html#method-i-prefix","(op)","<p>For prefix unary operator.  <code>a.prefix op</code> will run parser <code>op</code> for 0 or more times and eventually run parser …\n"],["range","RParsec::Parsers","RParsec/Parsers.html#method-i-range","(from, to, msg = \"#{as_char from}..#{as_char to} expected\")","<p>A parser that succeeds if the current input is within a certain range.\n"],["regexp","RParsec::Parsers","RParsec/Parsers.html#method-i-regexp","(ptn, expected = \"/#{ptn}/ expected\")","<p>A parser that succeeds if the current inputs match the given regular expression. The matched string is …\n"],["repeat","RParsec::FunctorMixin","RParsec/FunctorMixin.html#method-i-repeat","(n)","<p>Create a <code>Proc</code>, when called, repeatedly call <code>self</code> for <code>n</code> times.  The same arguments are passed to each …\n"],["repeat","RParsec::Functors","RParsec/Functors.html#method-i-repeat","(n, &block)","<p>Create a <code>Proc</code>, when called, repeatedly call <code>block</code> for <code>n</code> times.  The same arguments are passed to each …\n"],["repeat","RParsec::Parser","RParsec/Parser.html#method-i-repeat","(min, max = min)","<p>To create a parser that repeats <code>self</code> for a minimum <code>min</code> times, and maximally <code>max</code> times.  All return values …\n"],["repeat_","RParsec::Parser","RParsec/Parser.html#method-i-repeat_","(min, max = min)","<p>To create a parser that repeats <code>self</code> for a minimum <code>min</code> times, and maximally <code>max</code> times.  Only the return …\n"],["reverse_curry","RParsec::FunctorMixin","RParsec/FunctorMixin.html#method-i-reverse_curry","(ary = arity)","<p>Create a <code>Proc</code> that’s curriable.  When curried, parameters are passed in from right to left. i.e. …\n"],["reverse_curry","RParsec::Functors","RParsec/Functors.html#method-i-reverse_curry","(arity, &block)","<p>Create a <code>Proc</code> that’s curriable.  When curried, parameters are passed in from right to left. i.e. …\n"],["reverse_uncurry","RParsec::FunctorMixin","RParsec/FunctorMixin.html#method-i-reverse_uncurry","(= Functors.reverse_uncurry(&self))","<p>Uncurry a reverse curried closure.\n"],["reverse_uncurry","RParsec::Functors","RParsec/Functors.html#method-i-reverse_uncurry","(&block)","<p>Uncurry a reverse curried closure.\n"],["satisfies","RParsec::Parsers","RParsec/Parsers.html#method-i-satisfies","(expected, &pred)","<p>A parser that succeeds when the given predicate returns true (with the current input as the parameter). …\n"],["separated","RParsec::Parser","RParsec/Parser.html#method-i-separated","(delim)","<p>To create a parser that repeats <code>self</code> for unlimited times, with the pattern recognized by <code>delim</code> as separator …\n"],["separated1","RParsec::Parser","RParsec/Parser.html#method-i-separated1","(delim)","<p>To create a parser that repeats <code>self</code> for unlimited times, with the pattern recognized by <code>delim</code> as separator …\n"],["seq","RParsec::Monad","RParsec/Monad.html#method-i-seq","(other)","<p>Run the <em>seq</em> operation on the encapsulated object following the monad law.  If <code>seq</code> is not defined by the …\n"],["seq","RParsec::Parser","RParsec/Parser.html#method-i-seq","(other, &block)","<p><code>a.seq b</code> will sequentially run <code>a</code> then <code>b</code>.  The result of <code>b</code> is preserved as return value.  If a <code>block</code> is …\n"],["sequence","RParsec::Parsers","RParsec/Parsers.html#method-i-sequence","(*parsers, &proc)","<p>A parser that sequentially run the given <code>parsers</code>.  The result of the last parser is used as return value. …\n"],["set_index","RParsec::Parsers","RParsec/Parsers.html#method-i-set_index","(ind)","<p>A parser that moves the current input pointer to a certain index.\n"],["shorter","RParsec::Parsers","RParsec/Parsers.html#method-i-shorter","(*parsers)",""],["shortest","RParsec::Parsers","RParsec/Parsers.html#method-i-shortest","(*parsers)","<p>A parser that tries all given alternative <code>parsers</code> and picks the one with the shortest match.\n"],["some","RParsec::Parser","RParsec/Parser.html#method-i-some","(max)","<p>To create a parser that repeats <code>self</code> for at most <code>max</code> times. All return values are collected in an array. …\n"],["some_","RParsec::Parser","RParsec/Parser.html#method-i-some_","(max)","<p>To create a parser that repeats <code>self</code> for at most <code>max</code> times. Only the return value of the last execution …\n"],["sort","RParsec::Operators","RParsec/Operators.html#method-c-sort","(ops)","<p>Sort an array of operators so that contained operator appears after containers. When no containment exist …\n"],["str","RParsec::Parsers","RParsec/Parsers.html#method-i-str","(str, msg = \"\\\"#{str}\\\" expected\")",""],["string","RParsec::Parsers","RParsec/Parsers.html#method-i-string","(str, msg = \"\\\"#{str}\\\" expected\")","<p>A parser that matches the given string.\n"],["string_nocase","RParsec::Parsers","RParsec/Parsers.html#method-i-string_nocase","(str, expected = \"'#{str}' expected\")","<p>A parser that matches the given string, case insensitively.\n"],["sum","RParsec::Parsers","RParsec/Parsers.html#method-i-sum","(*alts)","<p>A parser that calls alternative parsers until one succeed, or any failure with input consumption beyond …\n"],["throwp","RParsec::Parsers","RParsec/Parsers.html#method-i-throwp","(symbol)","<p>A parser that throws a <code>symbol</code>.\n"],["to_s","RParsec::Parser","RParsec/Parser.html#method-i-to_s","()","<p>String representation\n"],["to_s","RParsec::Token","RParsec/Token.html#method-i-to_s","(= \"#{@kind}: #{@text}\")","<p>String representation of the token.\n"],["token","RParsec::Parser","RParsec/Parser.html#method-i-token","(kind)","<p><code>a.token(:word_token)</code> will return a Token object when <code>a</code> succeeds.  The matched string (or the string returned …\n"],["token","RParsec::Parsers","RParsec/Parsers.html#method-i-token","(*kinds, &proc)","<p>A parser that succeeds when the current input is a token with one of the the given token <code>kinds</code>.  If a …\n"],["uncurry","RParsec::FunctorMixin","RParsec/FunctorMixin.html#method-i-uncurry","(= Functors.uncurry(&self))","<p>Uncurry a curried closure.\n"],["uncurry","RParsec::Functors","RParsec/Functors.html#method-i-uncurry","(&block)","<p>Uncurry a curried closure.\n"],["value","RParsec::Monad","RParsec/Monad.html#method-i-value","(v)","<p>To create a value based on the monad impl.\n"],["value","RParsec::Parsers","RParsec/Parsers.html#method-i-value","(v)","<p>A parser that always succeeds with the given return value.\n"],["watch","RParsec::Parsers","RParsec/Parsers.html#method-i-watch","(&block)","<p>A parser that watches the current parser result without changing it.  The following assert will succeed: …\n"],["watchn","RParsec::Parsers","RParsec/Parsers.html#method-i-watchn","(&block)","<p>A parser that watches the current parser result without changing it.  The following assert will succeed: …\n"],["whitespace","RParsec::Parsers","RParsec/Parsers.html#method-i-whitespace","(expected = \"whitespace expected\")","<p>A parser that parses a white space character.\n"],["whitespaces","RParsec::Parsers","RParsec/Parsers.html#method-i-whitespaces","(expected = \"whitespace(s) expected\")","<p>A parser that parses 1 or more white space characters.\n"],["word","RParsec::Parsers","RParsec/Parsers.html#method-i-word","(expected = 'word expected')","<p>A parser that parses a word (starting with alpha or underscore, followed by 0 or more alpha, number or …\n"],["zero","RParsec::Parsers","RParsec/Parsers.html#method-i-zero","()","<p>A parser that always fails.\n"],["|","RParsec::Parser","RParsec/Parser.html#method-i-7C","(other)","<p><code>a | b</code> will run <code>b</code> when <code>a</code> fails.  <code>b</code> is auto-boxed to Parser when it is not of type Parser.\n"],["~","RParsec::Parser","RParsec/Parser.html#method-i-~","(msg = \"#{self} unexpected\")",""],["CHANGELOG","","CHANGELOG_md.html","","<p>rparsec Change Log\n<p>Unreleased\n<p>1.3.0 - 2025-01-20\n"],["README","","README_rdoc.html","","<p>rparsec\n<p>rparsec is a parser combinator library in Ruby. This is a port of Jparsec, written in Java.\n<p>Demo …\n"],["overview","","doc/overview_rdoc.html","","<p>Overview\n<p>Though rparsec API is quite easy to use, it still helps if one has an overview of how rparsec …\n"],["sql","","doc/sql_rdoc.html","","<p>SQL parser in rparsec\n<p>Powered by Ruby syntax, parser written in rparsec can be very concise. You have …\n"],["tips","","doc/tips_rdoc.html","","<p>Tips\n<p>Similar to any higher order combinator framework, rparsec program is not real easy to debug.  When …\n"]]}}