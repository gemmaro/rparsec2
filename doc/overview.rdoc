= Overview

Though rparsec API is quite easy to use, it still helps if one has an
overview of how rparsec works and be wary of some gotchas.  In this
article I'll try to answer questions that might be fequently asked.

== How do I start?

With rparsec, one creates Parser[rdoc-ref:RParsec::Parser] object in
terms of the production rule of the grammar.  Once a
Parser[rdoc-ref:RParsec::Parser] object is created, it can be used as
in:

  parse_result = parser.parse "your code goes here"

Depending on your need, this +parse_result+ can be either the
calculation result (as in the calculator example), or an abstract
syntax tree (as in the SQL parser example).

So how do you create Parser[rdoc-ref:RParsec::Parser] object?  Check
out Parsers[rdoc-ref:RParsec:Parsers] module.  It has everything for
you to start with.

You may very possibly want to include
Parsers[rdoc-ref:RParsec::Parsers] module into your parser
module/class. (You can of course not include
Parsers[rdoc-ref:RParsec::Parsers] module and just use individual
methods as in <tt>Parsers.char(?a)</tt>, <tt>Parsers.token(:word)</tt>
etc.  It is just way more convenient if the repetition of
Parsers[rdoc-ref:RParsec::Parsers] can be avoided.)

== How does rparsec work?

A Parser[rdoc-ref:RParsec::Parser] object accepts any input that wacks
and quacks like a string or an array, with +[]+ and +length+ methods.

Each Parser[rdoc-ref:RParsec::Parser] object encapsulates a piece of
parsing logic, that when executed, will read the current inputs and
optionally adjusts the cursor.

{Parsers#satisfies}[rdoc-ref:RParsec::Parsers#satisfies] uses the
associated predicate to check if the current input satisfies the
requirement.  And if it does, advances the cursor for one step.

Parsers#char[rdoc-ref:RParsec::Parsers#char],
Parsers#among[rdoc-ref:RParsec::Parsers#among],
Parsers#range[rdoc-ref:RParsec::Parsers#range] are all derived from
satisfies[rdoc-ref:RParsec::Parsers#satisfies].

Parsers#string[rdoc-ref:RParsec::Parsers#string],
Parsers#string_nocase[rdoc-ref::RParsec::Parsers#string_nocase]
matches the given string literal, case sensitively or insensitively.

Parsers#regexp[rdoc-ref:RParsec::Parsers#regexp] uses a regular
expression pattern to match the current input.

All parsers mentioned above are character level parsers.  They check
the current string input and are typically used in the lexing phase
(if you choose to do lexing/parsing as two phases.  It is not required
to have two phases though.)

It is relatively more straight-forward to use the 1-phase approach,
where all parsers work on the string level (as in the calculator
example).  However, when the grammar rule scales up and when
performance is a concern, 2-phase approach should be used to speed
things up and better isolate lexical/syntactical rules.

And suppose you want to do 2-phase parsing, lexcial analysis should result in tokens.
The Parser#token[rdoc-ref:RParsec::Parser#token] method is responsible for converting
the current string result to a token identified by the symbol specified.
This token will then be recognized during the second phase (syntactical analysis)
by the Parsers#token[rdoc-ref:RParsec::Parsers#token] method.

Syntactic parsers (created by
Parsers#token[rdoc-ref:RParsec::Parsers#token],
<tt>Keywords#[]</tt> or <tt>Operators#[]</tt> accept as input an
array of tokens.  This array of tokens are typically generated by some
lexical parsers.

The API to chain lexical parser and syntactical parser together is
Parser#nested[rdoc-ref:RParsec::Parser#nested] where syntactical
parser is nested within the lexical parser (that results in a token
array).

For the simplest case,

  word.token(:word).lexeme

will create a lexer that results in an array of word tokens.  And

  word.token(:word).lexeme.nested(syntax_parser)

chains a syntactical parser as nested within the lexer so that the
lexer result is passed as input to the syntactic parser.

== What are the step 1-2-3 in creating a typical parser?

=== Step 1: Lexer

A typical language contains keyword, operators and number literal,
string literal and regular words.

Parsers#integer[rdoc-ref:RParsec::Parsers#integer] and
Parsers#number[rdoc-ref:RParsec::Parsers#integer] can be used to scan
integer/number; string literal is better handled by
Parsers#regexp[rdoc-ref:RParsec::Parsers#regexp] (use
Parser#map[rdoc-ref:RParsec::Parser#map] to convert the matched string
literal and to deal with quotes/escapes.)

Keyword is easily handled by Keywords[rdoc-ref:RParsec::Keywords]
helper class.  Typically regular words can also be handled by this
class.

Operator is handled by Operators[rdoc-ref:RParsec::Operators] class.
Pass it all the operators you want to support, and it will take care
of ambiguities such that <tt>==</tt> is parsed as <tt>==</tt>, not two
<tt>=</tt> operators.

Once all lexers are ready, combine them together as in:

  operators = Operators.new(%w{+ - * / ++ --})
  keywords  = Keywords.case_sensitive(%w{if then else end})
  num       = number.token(:number)
  lexer     = operators.lexer | keywords.lexer | num

Use the lexeme[rdoc-ref:RParsec::Parser#lexeme] method to skip
whitespaces and comments and collect the tokens as an array:

  lexeme = lexer.lexeme << eof

Note, we use <tt><< eof</tt> to assert that after all tokens are read,
eof[rdoc-ref:RParsec::Parsers#eof] directly follows (meaning, all
inputs are consumed.  <tt><<</tt> operator reads as "followed by").

== Step 2: atomic syntactic parsers

To start syntactic parser that accepts the token array created by the
lexer, we need to first recognize the tokens we created.

Number and string literal will be recognized by
<tt>Parsers#token(:number)</tt> and <tt>Parsers#token(:stringlit)</tt>
(assuming <tt>:stringlit</tt> was used as the token identifier for
string literal).

To recognize the <tt>++</tt> operator, we use

  operators[:"++"]

To recognize <tt>if</tt> keyword, we use

  keywords[:if]

== Step 3: production rule

The last step is to build the parser following production rules.  The
alternative operator <tt>|</tt> and sequential operator <tt>>></tt>,
<tt><<</tt> are used most frequently to model production rules.

Parser#many[rdoc-ref::RParsec::Parser#many] combinator models the
"kleen star" construct in BNF.

Parsers#map[rdoc-ref:RParsec::Parsers#map] and
Parsers#sequence[rdoc-ref:RParsec::Parsers#sequence] are the two most
used combinators to associate semantic actions to syntactic rules.
For example:

  p_a = parser_a.map {|a|create_a_expression a}
  p_bcd = sequence(parser_b, parser_c, parser_d) do |b,c,d|
    create_bcd_expression b, c, d
  end

When production rule involves recursion (as in almost any expression
parser), the Parsers#lazy[rdoc-ref:RParsec::Parsers#lazy] can be used
to get around.  The usage is as simple as:

  expr = ... lazy { expr } ...

As in most recursive descent parsers, left-recursion is a nightmare.
Beware not to write a rparsec parser like this:

  expr = sequence(lazy{expr}, operators[:"+"], num)

It will fail with stack overflow!

A less obvious left-recursion is a production rule that looks like:

  expr = sequence(operator[:"-"].many, lazy{expr})

As many[rdoc-ref:RParsec::Parser#many] can occur 0 times, we have a
potential left recursion here.

I regret that I don't know enough to attack this problem.  But rparsec
does provide a nice work-around.  Most of the time left recursion
stems from left associative binary operator.  And rparsec has operator
precedence grammar support that can build the production rule for you.
Just declare the operators and their precedence, associativity in an
OperatorTable[rdoc-ref:RParsec::OperatorTable] and let
Expressions[rdoc-ref:RParsec::Expressions] class does the work.
(refer to the calculator example).

Operator table is probably more useful than you might expect it to be.
It can even be used for senario not as obvious as the arithmetic or
logical operators.  Indeed, any operation that takes one or two
participants and result in a new one may take advantage of operator
table.  The SQL +union+ and <tt>union all</tt> syntax, for example,
can be modeled as a binary operator too.

---

Originally written by Ben Yu at {rparsec overview}[https://web.archive.org/web/20150522220551/https://docs.codehaus.org/display/JPARSEC/rparsec+overview].
